<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HTTP-Server: src/request.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HTTP-Server
   &#160;<span id="projectnumber">0.3</span>
   </div>
   <div id="projectbrief">An project made at ESISAR</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">request.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface de traitement des requetes et reponses HTTP. </p>
<dl class="section author"><dt>Author</dt><dd>Quentin Giorgi </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>13 Decembre 2015</dd></dl>
<p>Fichier d'interface entre la bibliothèque et votre programme. Votre programme doit inclure ce fichier d'entete #include &lt;<a class="el" href="request_8h.html" title="Interface de traitement des requetes et reponses HTTP.">request.h</a>&gt; La compilation doit inclure l'option -L. -lrequest</p>
<p>Exemple de programme: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span> </div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span> </div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span> </div>
<div class="line"><span class="preprocessor">#include &lt;sys/socket.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;netinet/in.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;arpa/inet.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="request_8h.html">request.h</a>&quot;</span>   </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structmessage.html">message</a> *requete; </div>
<div class="line">    <a class="code" href="structmessage.html">message</a> *reponse;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> ( 1 ) {</div>
<div class="line">        <span class="comment">// on attend la reception d&#39;une requete </span></div>
<div class="line">        requete=<a class="code" href="request_8h.html#a84f3d458b916b971024022f2359ac338">getRequest</a>(8080);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Affichage de debug </span></div>
<div class="line">        printf(<span class="stringliteral">&quot;#########################################\nDemande recue depuis le client %d\n&quot;</span>,requete-&gt;<a class="code" href="structmessage.html#a14bfec4a2137426f4b33df4c470310da">clientId</a>); </div>
<div class="line">        printf(<span class="stringliteral">&quot;Client [%d] [%s:%d]\n&quot;</span>,requete-&gt;<a class="code" href="structmessage.html#a14bfec4a2137426f4b33df4c470310da">clientId</a>,inet_ntoa(requete-&gt;<a class="code" href="structmessage.html#a3c3a02f02d5ba650223498f95f30cb4c">clientAddress</a>-&gt;sin_addr),htons(requete-&gt;<a class="code" href="structmessage.html#a3c3a02f02d5ba650223498f95f30cb4c">clientAddress</a>-&gt;sin_port));</div>
<div class="line">        printf(<span class="stringliteral">&quot;Contenu de la demande %.*s\n\n&quot;</span>,requete-&gt;<a class="code" href="structmessage.html#a24bc7afeef646e268eefce5086872da8">len</a>,requete-&gt;<a class="code" href="structmessage.html#ae39c7ead60245755a62c4aefcb0ea53e">buf</a>);  </div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Si on a une reponse a faire</span></div>
<div class="line">        <span class="keywordflow">if</span> (argv[1]) {</div>
<div class="line">            <span class="keywordflow">if</span> (reponse=malloc(<span class="keyword">sizeof</span>(<a class="code" href="structmessage.html">message</a>))) { </div>
<div class="line">                reponse-&gt;<a class="code" href="structmessage.html#ae39c7ead60245755a62c4aefcb0ea53e">buf</a>=argv[1]; <span class="comment">// on devrait l&#39;allouer sinon</span></div>
<div class="line">                reponse-&gt;<a class="code" href="structmessage.html#a24bc7afeef646e268eefce5086872da8">len</a>=strlen(argv[1]); </div>
<div class="line">                reponse-&gt;<a class="code" href="structmessage.html#a14bfec4a2137426f4b33df4c470310da">clientId</a>=requete-&gt;<a class="code" href="structmessage.html#a14bfec4a2137426f4b33df4c470310da">clientId</a>; </div>
<div class="line">                <a class="code" href="request_8h.html#acd23356e16868a36c3f8361edb240a24">sendReponse</a>(reponse); </div>
<div class="line">                <span class="comment">// reponse est recopiée on peut tout de suite liberer la memoire</span></div>
<div class="line">                free(reponse); </div>
<div class="line">                <span class="comment">//optionnel, ici on clot la connexion tout de suite (HTTP/1.0) </span></div>
<div class="line">                <a class="code" href="request_8h.html#af8b1b52a1fe661d7ab6e33f6687e6d4f">requestShutdownSocket</a>(reponse-&gt;<a class="code" href="structmessage.html#a14bfec4a2137426f4b33df4c470310da">clientId</a>); </div>
<div class="line">            }</div>
<div class="line">        }       </div>
<div class="line">        <span class="comment">// on ne se sert plus de requete a partir de maintenant, on peut donc liberer... </span></div>
<div class="line">        <a class="code" href="request_8h.html#a78b0b35a1a9e7762488df107f3af787a">freeRequest</a>(requete); </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> (1);</div>
<div class="line">}</div>
<div class="ttc" id="arequest_8h_html"><div class="ttname"><a href="request_8h.html">request.h</a></div><div class="ttdoc">Interface de traitement des requetes et reponses HTTP.</div></div>
<div class="ttc" id="arequest_8h_html_a78b0b35a1a9e7762488df107f3af787a"><div class="ttname"><a href="request_8h.html#a78b0b35a1a9e7762488df107f3af787a">freeRequest</a></div><div class="ttdeci">void freeRequest(message *r)</div><div class="ttdoc">Procedure de libération de la memoire quand le programme en a fini avec une requete (message *).</div></div>
<div class="ttc" id="arequest_8h_html_a84f3d458b916b971024022f2359ac338"><div class="ttname"><a href="request_8h.html#a84f3d458b916b971024022f2359ac338">getRequest</a></div><div class="ttdeci">message * getRequest(short int port)</div><div class="ttdoc">Fonction de recuperation d'une requete, cette fonction est bloquante et doit etre appelée dans la bou...</div></div>
<div class="ttc" id="arequest_8h_html_acd23356e16868a36c3f8361edb240a24"><div class="ttname"><a href="request_8h.html#acd23356e16868a36c3f8361edb240a24">sendReponse</a></div><div class="ttdeci">void sendReponse(message *r)</div><div class="ttdoc">Procedure d'envoi d'un message au client HTTP.</div></div>
<div class="ttc" id="arequest_8h_html_af8b1b52a1fe661d7ab6e33f6687e6d4f"><div class="ttname"><a href="request_8h.html#af8b1b52a1fe661d7ab6e33f6687e6d4f">requestShutdownSocket</a></div><div class="ttdeci">void requestShutdownSocket(int i)</div><div class="ttdoc">Procedure de demande de cloture de la connexion, si la bibliothèque à encore des données à envoyer d'...</div></div>
<div class="ttc" id="astructmessage_html"><div class="ttname"><a href="structmessage.html">message</a></div><div class="ttdoc">Objet message qui peut etre soit une requete, soit une reponse.</div><div class="ttdef"><b>Definition:</b> <a href="request_8h_source.html#l00074">request.h:74</a></div></div>
<div class="ttc" id="astructmessage_html_a14bfec4a2137426f4b33df4c470310da"><div class="ttname"><a href="structmessage.html#a14bfec4a2137426f4b33df4c470310da">message::clientId</a></div><div class="ttdeci">unsigned int clientId</div><div class="ttdoc">clientId identifiant du client, recu dans une requete, doit etre recopier dans la reponse corresponda...</div><div class="ttdef"><b>Definition:</b> <a href="request_8h_source.html#l00077">request.h:77</a></div></div>
<div class="ttc" id="astructmessage_html_a24bc7afeef646e268eefce5086872da8"><div class="ttname"><a href="structmessage.html#a24bc7afeef646e268eefce5086872da8">message::len</a></div><div class="ttdeci">unsigned int len</div><div class="ttdoc">len La longueur du message recu</div><div class="ttdef"><b>Definition:</b> <a href="request_8h_source.html#l00076">request.h:76</a></div></div>
<div class="ttc" id="astructmessage_html_a3c3a02f02d5ba650223498f95f30cb4c"><div class="ttname"><a href="structmessage.html#a3c3a02f02d5ba650223498f95f30cb4c">message::clientAddress</a></div><div class="ttdeci">struct sockaddr_in * clientAddress</div><div class="ttdoc">iclientAddress pointeur vers une structure permettant de recuperer l'adresse IP et le port du client ...</div><div class="ttdef"><b>Definition:</b> <a href="request_8h_source.html#l00078">request.h:78</a></div></div>
<div class="ttc" id="astructmessage_html_ae39c7ead60245755a62c4aefcb0ea53e"><div class="ttname"><a href="structmessage.html#ae39c7ead60245755a62c4aefcb0ea53e">message::buf</a></div><div class="ttdeci">char * buf</div><div class="ttdoc">buf Un pointeur vers le message recu</div><div class="ttdef"><b>Definition:</b> <a href="request_8h_source.html#l00075">request.h:75</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition in file <a class="el" href="request_8h_source.html">request.h</a>.</p>
</div>
<p><a href="request_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmessage.html">message</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Objet message qui peut etre soit une requete, soit une reponse.  <a href="structmessage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ace6c609072c3b2eaca1e74b065d61dc4"><td class="memItemLeft" align="right" valign="top"><a id="ace6c609072c3b2eaca1e74b065d61dc4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAXCLIENT</b>&#160;&#160;&#160;10</td></tr>
<tr class="separator:ace6c609072c3b2eaca1e74b065d61dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a84f3d458b916b971024022f2359ac338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmessage.html">message</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="request_8h.html#a84f3d458b916b971024022f2359ac338">getRequest</a> (short int port)</td></tr>
<tr class="memdesc:a84f3d458b916b971024022f2359ac338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de recuperation d'une requete, cette fonction est bloquante et doit etre appelée dans la boucle principale du programme.  <a href="request_8h.html#a84f3d458b916b971024022f2359ac338">More...</a><br /></td></tr>
<tr class="separator:a84f3d458b916b971024022f2359ac338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b0b35a1a9e7762488df107f3af787a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="request_8h.html#a78b0b35a1a9e7762488df107f3af787a">freeRequest</a> (<a class="el" href="structmessage.html">message</a> *r)</td></tr>
<tr class="memdesc:a78b0b35a1a9e7762488df107f3af787a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure de libération de la memoire quand le programme en a fini avec une requete (message *).  <a href="request_8h.html#a78b0b35a1a9e7762488df107f3af787a">More...</a><br /></td></tr>
<tr class="separator:a78b0b35a1a9e7762488df107f3af787a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd23356e16868a36c3f8361edb240a24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="request_8h.html#acd23356e16868a36c3f8361edb240a24">sendReponse</a> (<a class="el" href="structmessage.html">message</a> *r)</td></tr>
<tr class="memdesc:acd23356e16868a36c3f8361edb240a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure d'envoi d'un message au client HTTP.  <a href="request_8h.html#acd23356e16868a36c3f8361edb240a24">More...</a><br /></td></tr>
<tr class="separator:acd23356e16868a36c3f8361edb240a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85da2e74873990c15111d9c7b4dc6b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="request_8h.html#ad85da2e74873990c15111d9c7b4dc6b3">writeDirectClient</a> (int i, char *buf, unsigned int len)</td></tr>
<tr class="memdesc:ad85da2e74873990c15111d9c7b4dc6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure (expérimentale) [alternative à sendReponse] d'envoi d'un buffer au client i.  <a href="request_8h.html#ad85da2e74873990c15111d9c7b4dc6b3">More...</a><br /></td></tr>
<tr class="separator:ad85da2e74873990c15111d9c7b4dc6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60779dd9b78eab2685f71a69a504b9dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="request_8h.html#a60779dd9b78eab2685f71a69a504b9dc">endWriteDirectClient</a> (int i)</td></tr>
<tr class="memdesc:a60779dd9b78eab2685f71a69a504b9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure (expérimentale) de déclaration de la fin de la réponse envoyée au client i HTTP.  <a href="request_8h.html#a60779dd9b78eab2685f71a69a504b9dc">More...</a><br /></td></tr>
<tr class="separator:a60779dd9b78eab2685f71a69a504b9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b1b52a1fe661d7ab6e33f6687e6d4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="request_8h.html#af8b1b52a1fe661d7ab6e33f6687e6d4f">requestShutdownSocket</a> (int i)</td></tr>
<tr class="memdesc:af8b1b52a1fe661d7ab6e33f6687e6d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure de demande de cloture de la connexion, si la bibliothèque à encore des données à envoyer d'un sendReponse précédent, la connexion ne sera fermée qu'à la fin de cet envoi.  <a href="request_8h.html#af8b1b52a1fe661d7ab6e33f6687e6d4f">More...</a><br /></td></tr>
<tr class="separator:af8b1b52a1fe661d7ab6e33f6687e6d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a60779dd9b78eab2685f71a69a504b9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60779dd9b78eab2685f71a69a504b9dc">&#9670;&nbsp;</a></span>endWriteDirectClient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void endWriteDirectClient </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure (expérimentale) de déclaration de la fin de la réponse envoyée au client i HTTP. </p>
<p>doit être utilisés si et seulement si vous utilisez writeDirectClient </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Le client </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78b0b35a1a9e7762488df107f3af787a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b0b35a1a9e7762488df107f3af787a">&#9670;&nbsp;</a></span>freeRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmessage.html">message</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure de libération de la memoire quand le programme en a fini avec une requete (message *). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Le message à libérer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84f3d458b916b971024022f2359ac338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f3d458b916b971024022f2359ac338">&#9670;&nbsp;</a></span>getRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmessage.html">message</a> * getRequest </td>
          <td>(</td>
          <td class="paramtype">short int&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de recuperation d'une requete, cette fonction est bloquante et doit etre appelée dans la boucle principale du programme. </p>
<p>Cette fonction essaie de récupérer une requête entière pour la livrer à votre programme, mais si des cas d'erreur se produisent,elle livre ce qui a été recu à l'instant t sans filtrage, c'est votre programme qui devra traiter ces cas d'erreurs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>port d'écoute de la socket, utilisé qu'au premier appel de la fonction, ensuite ce parametre est ignoré dans les appels successifs. <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>un pointeur vers une structure message. </dd></dl>

</div>
</div>
<a id="af8b1b52a1fe661d7ab6e33f6687e6d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b1b52a1fe661d7ab6e33f6687e6d4f">&#9670;&nbsp;</a></span>requestShutdownSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void requestShutdownSocket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure de demande de cloture de la connexion, si la bibliothèque à encore des données à envoyer d'un sendReponse précédent, la connexion ne sera fermée qu'à la fin de cet envoi. </p>
<p><br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>L'Id du client dont on doit fermer la connexion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd23356e16868a36c3f8361edb240a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd23356e16868a36c3f8361edb240a24">&#9670;&nbsp;</a></span>sendReponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sendReponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmessage.html">message</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure d'envoi d'un message au client HTTP. </p>
<p>Ici la réponse est totalement formée (entête et body) dans un buffer en mémoire avant d'être envoyée au client. cette fonction recopie les données dans un buffer et s'assure de les envoyer quand la socket est disponible (la procédure appelante put tout de suite libérer la mémoire) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Le message à envoyer (recopié par la bibliothèque) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad85da2e74873990c15111d9c7b4dc6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85da2e74873990c15111d9c7b4dc6b3">&#9670;&nbsp;</a></span>writeDirectClient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void writeDirectClient </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure (expérimentale) [alternative à sendReponse] d'envoi d'un buffer au client i. </p>
<p>Il est parfois pratique d'écrire au client au fur et à mesure du traitement de la requête. La librairie ne peut pas determiner toute seule la fin de la réponse. Si vous utilisez cette fonction il faut OBLIGATOIREMENT utiliser la fonction endWriteDirectClient quand la réponse est finie. L'intérêt ici est de ne pas avoir à stocker dans des buffers la totalité de la réponse. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Le client </td></tr>
    <tr><td class="paramname">buf</td><td>Le message à envoyer (non recopié par la bibliothèque) </td></tr>
    <tr><td class="paramname">len</td><td>La longueur du message à envoyer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
